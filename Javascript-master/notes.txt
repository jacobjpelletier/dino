Udacity Notes on OOP JS

A. Objects in Depth
    1. Create and modify properties
        a. Creating objects
            - literal notation:

                const myObject = {};

            - Object constructor function:

                const myObject = new Object();

            - To create a new, blank (i.e., “empty”) object, you can use object literal notation,
            or the Object() constructor function.
            - the recommended way to create new objects in JavaScript is to use literal notation.
        b. modifying properties
            - Keep in mind that data within objects are mutable, meaning that data can be changed. There are a few
            exceptions to this, but for now, let's see how we can modify/reassign existing properties in an object.
            - consider the cat object:

            const cat = {
              age: 2,
              name: 'Bailey',
              meow: function () {
                console.log('Meow!');
              },
              greet: function (name) {
                console.log(`Hello ${name}`);
              }
            };

            - now lets modify:

            cat.age += 1;
            cat.age;
            // 3
            cat.name = 'Bambi';
            cat.name;
            // 'Bambi'

            - cat object now looks like:

            {
              age: 3,
              name: 'Bambi',
              meow: function () {
                console.log('Meow!');
              },
              greet: function (name) {
                console.log(`Hello ${name}`);
              }
            };

        c. adding properties
            - Properties can be added to objects simply by specifying the property name, then giving it a value.
            Let's start off with a blank object, then add two properties:

            const printer = {};
            printer.on = true;
            printer.mode = 'black and white';

            - The above example uses dot notation to add properties, but keep in mind that square bracket notation
            works just as well:

            printer['remainingSheets'] = 168;

            - Likewise, we can add a method to the printer object in a similar manner. This time, the value of the
            property is an anonymous (i.e., unnamed) function:

            printer.print = function () {
              console.log('The printer is printing!');
            };

            - printer now looks like:

            {
              on: true,
              mode: 'black and white',
              remainingSheets: 168,
              print: function () {
                console.log('The printer is printing!');
              }
            }

        d. removing properties
            - Recall that since objects are mutable, not only can we modify existing properties (or even add new ones)
              we can also delete properties from objects.

            - Say that the printer object above actually doesn't have any modes (i.e., 'black and white', 'color', etc.).
              We can go ahead and remove that property from printer using the delete operator.

              delete printer.mode;
              // true

            - Note that delete directly mutates the object at hand. If we try to access a deleted property, the
            JavaScript interpreter will no longer be able to find the mode property because the mode key (along with its
            value, true) have been deleted:

                printer.mode;
                // undefined

        e. passing arguments
            - In JavaScript, a primitive (e.g., a string, number, boolean, etc.) is immutable. In other words, any
            changes made to an argument inside a function effectively creates a copy local to that function, and does
            not affect the primitive outside of that function. Check out the following example:

            function changeToEight(n) {
              n = 8; // whatever n was, it is now 8... but only in this function!
            }
            let n = 7;
            changeToEight(n);
            console.log(n);
            // 7

        f. passing an object
            - On the other hand, objects in JavaScript are mutable. If you pass an object into a function, Javascript
            passes a reference to that object. Let's see what happens if we pass an object into a function and then
            modify a property:

            let originalObject = {
              favoriteColor: 'red'
            };
            function setToBlue(object) {
              object.favoriteColor = 'blue';
            }
            setToBlue(originalObject);
            originalObject.favoriteColor;
            // 'blue'

            - How did this happen? Well, since objects in JavaScript are passed by reference, if we make changes to that
            reference, we're actually directly modifying the original object itself!
            - What's more: the same rule applies when re-assigning an object to a new variable, and then changing that
            copy. Again, since objects are passed by reference, the original object is changed as well. Let's take a
            look at this more closely with another example.
            - Consider this iceCreamOriginal object, which shows the amount of ice cream cones each instructor has eaten:

            const iceCreamOriginal = {
              Andrew: 3,
              Richard: 15
            };

            const iceCreamCopy = iceCreamOriginal;
            iceCreamCopy.Richard;
            // 15

            iceCreamCopy.Richard = 99;
            iceCreamCopy.Richard;
            // 99
            iceCreamOriginal.Richard;
            // 99

            - so, initially Richard has 15 ice cream. reference to original is passed to copy, and value
            of 99 replaced copy, which also replaces original

        g. Comparing an object with another object
            - what happens when you compare one object with another?

            const parrot = {
              group: 'bird',
              feathers: true,
              chirp: function () {
                console.log('Chirp chirp!');
              }
            };
            const pigeon = {
              group: 'bird',
              feathers: true,
              chirp: function () {
                console.log('Chirp chirp!');
              }
            };

            - are parrot and pigeon equal? nope
            - What's going on here? As it turns out, the expression will only return true when comparing two references
            to exactly the same object. Using what we now know about passing objects, let's confirm this. To start off,
            let's create a new variable, myBird, and assign it to one of the objects above:

            const myBird = parrot;
            myBird === parrot;
            // true

        h. summary
            - Objects are commonly created with literal notation, and can include properties that point to functions
            called methods. Methods are accessed the same way as other properties of objects, and can be invoked the
            same way as regular functions, except they automatically have access to the other properties of their parent
            object.

            - By default, objects are mutable (with a few exceptions), so data within them can be altered. New properties
            can be added, and existing properties can be modified by simply specifying the property name and assigning
            (or re-assigning) a value. Additionally, properties and methods of an object can be deleted as well with the
            delete operator, which directly mutates the object.

            - We've modified objects quite a bit in this section, and even added new methods into them. In the very next
            section, we'll take a closer look at invoking these methods, as well as how these methods can directly access
            and modify an object itself!

    2.  Invoking Object Methods
        a. Functions vs methods.
            - We can add functionality to objects by adding methods to them

            function sayHello () {
              console.log('Hi there!');
            }
            const developer = {
              name: 'Andrew'
            };
            developer.sayHello = function () {
              console.log('Hi there!');
            };
            // now looks like this
            {
              name: 'Andrew',
              sayHello: function () {
                console.log('Hi there!');
              }
            }

        b. calling methods
            - We can access a function in an object using the property name. Again, another name for a function property
            of an object is a method. We can access it the same way that we do with other properties: by using dot
            notation or square bracket notation. Let's take a look back at the updated developer object above, then
            invoke its sayHello() method:

            const developer = {
              name: 'Andrew',
              sayHello: function () {
                console.log('Hi there!');
              }
            };
            developer.sayHello();
            // 'Hi there!'
            developer['sayHello']();
            // 'Hi there!'

        c. passing arguments into methods
            - If the method takes arguments, you can proceed the same way, too:

            const developer = {
              name: 'Andrew',
              sayHello: function () {
                console.log('Hi there!');
              },
              favoriteLanguage: function (language) {
                console.log(`My favorite programming language is ${language}`);
              }
            };
            developer.favoriteLanguage('JavaScript');
            // My favorite programming language is JavaScript'

        d. call methods by property name
            - We've been using anonymous functions (i.e., functions without a name) for object methods. However, naming
            those functions is still valid JavaScript syntax. Consider the following object, greeter:

            const greeter = {
              greet: function sayHello() {
                console.log('Hello!');
              }
            };

            - Note that the greet property points to a function with a name: sayHello. Whether this function is named or
            not, greet is invoked the same way:

            greeter.greet();
            // 'Hello!'

            - Named functions are great for a smoother debugging experience, since those functions will have a useful name
            to display in stack traces. They're completely optional, however, and you'll often read code written by
            developers who prefer one way or the other.

        e. a method can access the object it was called on
            - Recall that an object can contain data and the means to manipulate that data. But just how can an object
            reference its own properties, much less manipulate some of those properties itself? This is all possible
            with the this keyword!

            const triangle = {
              type: 'scalene',
              identify: function () {
                console.log(`This is a ${this.type} triangle.`);
              }
            };

        f. summary
            -     A method is a function property of an object. It is accessed the same way as any other property of the
            object (i.e., using dot notation or square bracket notation), and is invoked the same way as a regular
            function outside of an object (i.e., adding parentheses to the end of the expression).
            - Since an object is a collection of data and the means to operate on that data, a method can access the
            object it was called on using the special this keyword. The value of this is determined when a method is
            invoked, and its value is the object on which the method was called. Since this is a reserved word in
            JavaScript, its value cannot be used as an identifier. Feel free to check out the links below for an
            additional look at methods and their relationship with this.
            - We've spent a bit of time on this inside objects, but did you know that the value of this can have
            different meanings outside an object? In the next section, we'll take a close look at globals, their
            relationship with this, and the implications of using them.

    3. Beware of globals
        a. Previously, we saw that the properties and methods contained inside an object belong to that object. Let's
        drive this home with one quick example:

        const chameleon = {
          eyes: 2,
          lookAround: function () {
             console.log(`I see you with my ${this.eyes} eyes!`);
          }
        };
        chameleon.lookAround();
        // 'I see you with my 2 eyes!'

        b. How the function is invoked determines the value of this inside the function.
        c. When a regular function is invoked, the value of this is the global window object.
        d. window object
            - If you haven't worked with the window object yet, this object is provided by the browser environment and
            is globally accessible to your JavaScript code using the identifier, window. This object is not part of the
            JavaScript specification (i.e., ECMAScript); instead, it is developed by the W3C.
            - This window object has access to a ton of information about the page itself, including:
                -The page's URL (window.location;)
                -The vertical scroll position of the page (window.scrollY')
                -Scrolling to a new location (window.scroll(0, window.scrollY + 200); to scroll 200 pixels down from the
                current location)
                -Opening a new web page (window.open("https://www.udacity.com/");)
        e. Global Variables are Properties on window
            - Since the window object is at the highest (i.e., global) level, an interesting thing happens with global
            variable declarations. Every variable declaration that is made at the global level (outside of a function)
            automatically becomes a property on the window object!
        f. Globals and var, let, and const
            - The keywords var, let, and const are used to declare variables in JavaScript. var has been around since
            the beginning of the language, while let and const are significantly newer additions (added in ES6).
            - Only declaring variables with the var keyword will add them to the window object. If you declare a variable
            outside of a function with either let or const, it will not be added as a property to the window object.
        g. Global Functions are Methods on window
            - Similarly to how global variables are accessible as properties on the window object, any global function
            declarations are accessible on the window object as methods:

            function learnSomethingNew() {
              window.open('https://www.udacity.com/');
            }
            window.learnSomethingNew === learnSomethingNew
            // true

        h. avoid globals
            - Counterintuitively, though, global variables and functions are not ideal. There are actually a number of
            reasons why, but the two we'll look at are:

              Tight coupling
              Name collisions

            - Tight Coupling
                - Tight coupling is a phrase that developers use to indicate code that is too dependent on the details
                of each other. The word "coupling" means the "pairing of two items together." In tight coupling, pieces
                of code are joined together in a way where changing one unintentionally alters the functioning of some
                other code:

                var instructor = 'Richard';
                function richardSaysHi() {
                  console.log(`${instructor} says 'hi!'`);
                }

                -  If we refactored this code by changing the variable from instructor to teacher, this would break the
                richardSaysHi() function (or we'd have to update it there, too!). This is a (simple) example of
                tightly-coupled code.

            - name collisions
                - A name collision occurs when two (or more) functions depend on a variable with the same name. A major
                problem with this is that both functions will try to update the variable and or set the variable, but
                these changes are overridden by each other!

                let counter = 1;

                function addDivToHeader () {
                  const newDiv = document.createElement('div');
                  newDiv.textContent = 'div number ' + counter;

                  counter = counter + 1;

                  const headerSection = document.querySelector('header');
                  headerSection.appendChild(newDiv)
                }

                function addDivToFooter() {
                  const newDiv = document.createElement('div');
                  newDiv.textContent = 'div number ' + counter;

                  counter = counter + 1;

                  const headerSection = document.querySelector('footer');
                  headerSection.appendChild(newDiv)
                }

                - In this code, we have an addDivToHeader() function and a addDivToFooter() function. Both of these
                functions create a <div> element and increment a counter variable.
                - So what should you do instead? You should write as few global variables as possible. Write your
                variables inside of the functions that need them, keeping them as close to where they are needed as
                possible. Now, there are times when you'll need to write global variables, but you should only write
                them as a last resort.

    4. Object Methods
        a. Do you remember earlier when we used the Object() constructor function to create (i.e., instantiate) new
        objects with the new keyword?
            - const myNewFancyObject = new Object();
        b. Object.keys() and Object.values()
            - At its core, an object is just a collection of key/value pairs. What if we want to extract only the keys
            from an object? Say we have this object representing a real-life dictionary:

            const dictionary = {
              car: 'automobile',
              apple: 'healthy snack',
              cat: 'cute furry animal',
              dog: 'best friend'
            };

            - When Object.keys() is given an object, it extracts just the keys of that object, then returns those keys
            in an array:

            Object.keys(dictionary);
            // ['car', 'apple', 'cat', 'dog']

            - So Object.keys() gives returns an array of the provided object's property names. Likewise, if we want a
            list of the values of an object, we can use Object.values():

            Object.values(dictionary);
            // ['automobile', 'healthy snack', 'cute furry animal', 'best friend']

        c. summary
            - The Object() constructor function has access to several methods to aid in development. To extract property
            names and values from an object, we can use:
            - Object.keys() returns an array of a given object's own keys (property names).
            - Object.values() returns an array of a given object's own values (property values).

B. Functions at runtime
    1. functions are first class objects
        a. this means that you can do with a function just about anything that you can do with other elements, such as
        numbers, strings, objects, arrays, etc. JavaScript functions can:

            - Be stored in variables
            - Be returned from a function.
            - Be passed as arguments into another function.

        b. Recall that a function must always return a value. Whether the value is explicitly specified in a return
        statement (e.g., returning a string, boolean, array, etc.), or the function implicitly returns undefined (e.g.,
        a function that simply logs something to the console), a function will always return just one value.
        c. Since we know that functions are first-class functions, we can treat a function as a value and just as easily
         return a function from another function! A function that returns another function is known as higher-order
         function. Consider this example:

         function alertThenReturn() {
           alert('Message 1!');
           return function () {
             alert('Message 2!');
           };
         }
         // message 1
         const innerFunction = alertThenReturn();
         innerFunction();
         // alerts 'Message 2!'

    2. Callbacks
        a. Callback Functions
            - Recall that JavaScript functions are first-class functions. We can do with functions just about everything
            we can do with other values -- including passing them into other functions! A function that takes other
            functions as arguments (and/or returns a function, as we learned in the previous section) is known as a
            higher-order function. A function that is passed as an argument into another function is called a callback
            function.
            - We'll be focusing on callbacks in this section. Callback functions are great because they can delegate
            calling functions to other functions. They allow you to build your applications with composition, leading
            to cleaner and more efficient code.
        b. Array Methods
            - Where have you probably seen callback functions used? In array methods! Functions are commonly passed into
            array methods and called on elements within an array (i.e., the array on which the method was called).
            - forEach()
                - Array's forEach() method takes in a callback function and invokes that function for each element in
                the array. In other words, forEach() allows you to iterate (i.e., loop) through an array, similar to
                using a for loop. Check out its signature:

                array.forEach(function callback(currentValue, index, array) {
                    // function code here
                });

                - Let's say we have a simple function, logIfOdd(), that takes in a single number and logs it to the
                console if that number is an odd number:

                function logIfOdd(n) {
                  if (n % 2 !== 0) {
                    console.log(n);
                  }
                }
                logIfOdd(2);
                // (nothing is logged)
                logIfOdd(3);
                // 3

                [1, 5, 2, 4, 6, 3].forEach(function logIfOdd(n) {
                  if (n % 2 !== 0) {
                    console.log(n);
                  }
                });

                // 1
                // 5
                // 3

                // OR JUST PASS FUNCTION NAME

                [1, 5, 2, 4, 6, 3].forEach(logIfOdd);

                // 1
                // 5
                // 3

                // OR PASS AN ANONYMOUS FUNCTION
                [1, 5, 2, 4, 6, 3].forEach(function (n) {
                  if (n % 2 !== 0) {
                    console.log(n);
                  }
                });

                // 1
                // 5
                // 3

            - map()
                - Array's map() method is similar to forEach() in that it invokes a callback function for each element
                in an array. However, map() returns a new array based on what's returned from the callback function.
                Check out the following:

                const names = ['David', 'Richard', 'Veronika'];
                const nameLengths = names.map(function(name) {
                  return name.length;
                });

                - So nameLengths will be a new array: [5, 7, 8]. Again, it is important to understand that the map()
                method returns a new array; it does not modify the original array.

            - filter()
                - Array's filter() method is similar to the map() method:
                    -It is called on an array
                    -It takes a function as an argument
                    -It returns a new array
                - The difference is that the function passed to filter() is used as a test, and only items in the array
                that pass the test are included in the new array. Consider the following example:

                const names = ['David', 'Richard', 'Veronika'];
                const shortNames = names.filter(function(name) {
                  return name.length < 6;
                });

                - The difference is that the function passed to filter() is used as a test, and only items in the array
                that pass the test are included in the new array. Consider the following example:

    3. Scope
        a. If you took Intro to Javascript, you learned about block scope vs. function scope. These determine where a
        variable can be seen in some code. Computer scientists call this lexical scope.
        - However, there also exists another kind of scope called runtime scope. When a function is run, it creates a
        new runtime scope. This scope represents the context of the function, or more specifically, the set of variables
        available for the function to use.
        b. Javascript is function scoped
            - This is all because variables in JavaScript are traditionally defined in the scope of a function, rather
            than in the scope of a block. Since entering a function will change scope, any variables defined inside that
            function are not available outside of that function. On the other hand, if there are any variables defined
            inside a block (e.g., within an if statement), those variables are available outside of that block.
        c. ES6 syntax allows for additional scope while declaring variables with the let and const keywords. These
        keywords are used to declare block-scoped variables in JavaScript, and largely replace the need for var.
        d. scope chain
            - Whenever your code attempts to access a variable during a function call, the JavaScript interpreter will
            always start off by looking within its own local variables. If the variable isn't found, the search will
            continue looking up what is called the scope chain.
        e. variable shadowing
            - What happens when you create a variable with the same name as another variable somewhere in the scope chain?
            - JavaScript won't throw an error or otherwise prevent you from creating that extra variable. In fact, the
            variable with local scope will just temporarily "shadow" the variable in the outer scope. This is called
            variable shadowing. Consider the following example:

            const symbol = '¥';
            function displayPrice(price) {
              const symbol = '$';
              console.log(symbol + price);
            }
            displayPrice('80');
            // '$80'

        f. summary
            - When a function is run, it creates its own scope. A function's scope is the set of variables available for
            use within that function. The scope of a function includes:
                -The function's arguments.
                -Local variables declared within the function.
                -Variables from its parent function's scope.
                -Global variables.
            - Variables in JavaScript are also function-scoped. This means that any variables defined inside a function
            are not available for use outside the function, though any variables defined within blocks (e.g. if or for)
            are available outside that block.
            - When it comes to accessing variables, the JavaScript engine will traverse the scope chain, first looking
            at the innermost level (e.g., a function's local variables), then to outer scopes, eventually reaching the
            global scope if necessary.
    4. Closures
        a. Functions Retain Their Scope
            - We just looked at how function scope works and how a scope chain is created. Just to recap: when an
            identifier (i.e., a variable) is used, the JavaScript engine will check the scope chain to retrieve the
            value for that identifier. The identifier might be found in the local scope (either in the function or block).
            If it's not found locally, then it might exist in an outer scope. It'll then keep checking the next outer
            scope followed by the next outer scope until it reaches the global scope (if necessary).
            - Identifier lookup and the scope chain are really powerful tools for a function to access identifiers in
            the code. In fact, this lets you do something really interesting: create a function now, package it up with
            some variables, and save it to run later. If you have five buttons on the screen, you could write five
            different click handler functions, or you could use the same code five times with different saved values.

            function remember(number) {
                return function() {
                    return number;
                }
            }
            const returnedFunction = remember(5);
            console.log( returnedFunction() );
            // 5

            - This process of a function retaining access to its scope is called a closure. In this example, the inner
            function "closes over" number. A closure can capture any number of parameters and variables that it needs.
            MDN defines a closure as:

            "the combination of a function and the lexical environment within which that function was declared."

            - This definition might not make a lot of sense if you don't know what the words "lexical environment" mean.
            The ES5 spec refers to a lexical environment as:

            "the association of Identifiers to specific variables and functions based upon the lexical nesting structure
            of ECMAScript code."

            - In this case, the "lexical environment" refers the code as it was written in the JavaScript file. As such,
            a closure is:

                - The function itself, and
                - The code (but more importantly, the scope chain of) where the function is declared

            - When a function is declared, it locks onto the scope chain. You might think this is pretty straightforward
            since we just looked at that in the previous section. What's really interesting about a function, though,
            is that it will retain this scope chain -- even if it is invoked in a location other than where it was
            declared. This is all due to the closure!

        b. creating a closure
            - Every time a function is defined, closure is created for that function. Strictly speaking, then, every
            function has closure! This is because functions close over at least one other context along the scope chain:
            the global scope. However, the capabilities of closures really shine when working with a nested function
            (i.e., a function defined within another function).
            - Recall that a nested function has access to variables outside of it. From what we have learned about the
            scope chain, this includes the variables from the outer, enclosing function itself (i.e., the parent function)!
            These nested functions close over (i.e., capture) variables that aren't passed in as arguments nor defined
            locally, otherwise known as free variables.
            - As we saw with the remember() function earlier, it is important to note that a function maintains a
            reference to its parent's scope. If the reference to the function is still accessible, the scope persists!
        c. closures ans scope
            - Closures and scope are so closely related that you may even be surprised you had been working with them
            all along! Let's revisit an example from the previous section:

            const myName = 'Andrew';
            function introduceMyself() {
              const you = 'student';
              function introduce() {
                console.log(`Hello, ${you}, I'm ${myName}!`);
              }
              return introduce();
            }
            introduceMyself();
            // 'Hello, student, I'm Andrew!'

            - To recap: myName is a variable defined outside a function, hence it's a global variable in the global
            scope. In other words, myName is available for all functions to use.
        d. applications of closures
            - To recap, we've seen two common and powerful applications of closures:
                - Passing arguments implicitly.
                - At function declaration, storing a snapshot of scope.
        e. garbage collection
            - JavaScript manages memory with automatic garbage collection. This means that when data is no longer
            referable (i.e., there are no remaining references to that data available for executable code), it is
            "garbage collected" and will be destroyed at some later point in time. This frees up the resources
            (i.e., computer memory) that the data had once consumed, making those resources available for re-use.
            - Let's look at garbage collection in the context of closures. We know that the variables of a parent
            function are accessible to the nested, inner function. If the nested function captures and uses its parent's
            variables (or variables along the scope chain, such as its parent's parent's variables), those variables
            will stay in memory as long as the functions that utilize them can still be referenced.
            - As such, referenceable variables in JavaScript are not garbage collected! Let's quickly look back at the
            myCounter function from the previous video:

            function myCounter() {
              let count = 0;
              return function () {
                count += 1;
                return count;
              };
            }

            - The existence of the nested function keeps the count variable from being available for garbage collection,
            therefore count remains available for future access. After all, a given function (and its scope) does not
            end when the function is returned. Remember that functions in JavaScript retain access to the scope that
            they were created in!
        f. summary
            - A closure refers to the combination of a function and the lexical environment in which that function was
            declared. Every time a function is defined, closure is created for that function. This is especially
            powerful in situations where a function is defined within another function, allowing the nested function to
            access variables outside of it. Functions also keep a link to its parent's scope even if the parent has
            returned. This prevents data in its parents from being garbage collected.
            - At this point, we've worked a lot with functions declarations and function expressions. Did you know that
            you can write functions that can be immediately invoked after they're defined? We'll check out these
            immediately-invoked function expressions (IIFE's, or iiffy's) in the next section!
    5. immediately invoked function expressions
        a. function declarations vs function expressions
            - A function declaration defines a function and does not require a variable to be assigned to it. It simply
            declares a function, and doesn't itself return a value. Here's an example:

            function returnHello() {
              return 'Hello!';
            }

            - On the other hand, a function expression does return a value. Function expressions can be anonymous or
            named, and are part of another expression's syntax. They're commonly assigned to variables, as well. Here's
            the same function as a function expression:

            // anonymous
            const myFunction = function () {
              return 'Hello!';
            };
            // named
            const myFunction = function returnHello() {
              return 'Hello!';
            };

        b. Immediately-Invoked Function Expressions: Structure and Syntax
            - An immediately-invoked function expression, or IIFE (pronounced iffy), is a function that is called
            immediately after it is defined. Check out the following example:

            (function sayHi(){
                alert('Hi there!');
              }
            )();
            // alerts 'Hi there!'

            - The syntax might seem a bit odd, but all we're doing is wrapping a function in parentheses, then adding a
            pair of parentheses at the end of that to invoke it!
        c. passing arguments into IIFE's
            - Let's look into how we can go about passing arguments into IIFE's. Consider the following example of an
            anonymous function expression that takes in a single argument:

            (function (name){
                alert(`Hi, ${name}`);
              }
            )('Andrew');
            // alerts 'Hi, Andrew'

            - The second pair of parentheses not only immediately executes the function preceding it -- it's also the
            place to put any arguments that the function may need! We pass in the string 'Andrew', which is stored in
            the function expression's name variable. It is then immediately invoked, alerting the message 'Hi, Andrew'
            onto the screen.
            - Here's another example of an IIFE, this time taking two arguments and returning their product:

            (function (x, y){
                console.log(x * y);
              }
            )(2, 3);
            // 6

        d. IIFE and private scope
            - One of the primary uses for IIFE's is to create private scope (i.e., private state). Recall that variables
             in JavaScript are traditionally scoped to a function. Knowing this, we can leverage the behavior of
             closures to protect variables or methods from being accessed! Consider the following example of a simple
             closure within an IIFE, referenced by myFunction:

             const myFunction = (
               function () {
                 const hi = 'Hi!';
                 return function () {
                   console.log(hi);
                 }
               }
             )();

            - In the above image, an immediately-invoked function expression is used to immediately run a function.
            This function runs and returns an anonymous function that is stored in the myFunction variable.
            - Note that the function that is being returned closes over (i.e., captures) the hi variable. This allows
            myFunction to maintain a private, mutable state that cannot be accessed outside the function! What's more:
            because the function expressed is called immediately, the IIFE wraps up the code nicely so that we don't
            pollute the global scope.
        e. IIFE's private scope, and event handling
            - Let's check out another example of an immediately-invoked function expression -- this time in the context
            of handling an event. Say that we want to create a button on a page that alerts the user on every other click.
            One way to begin doing this would be to keep track of the number of times that the button was clicked. But
            how should we maintain this data?
            - Next, we'll add an event listener to button, and listen for a 'click' event. Then, we'll pass in an IIFE
             as the second argument:

             // button.js
             button.addEventListener('click', (function() {
               let count = 0;

               return function() {
                 count += 1;

                 if (count === 2) {
                   alert('This alert appears every other press!');
                   count = 0;
                 }
               };
             })());

             - First, we declare a local variable, count, which is initially set to 0. We then return a function from
             that function. The returned function increments count, but alerts the user and resets the count back to 0
             if the count reaches 2.
             - What is important to note is that the returned function closes over the count variable. That is, because
             a function maintains a reference to its parent's scope, count is available for the returned function to use!
             As a result, we immediately invoke a function that returns that function. And since the returned function
             has access to the internal variable, count, a private scope is created -- effectively protecting the data!
        f. benefits of immediately invoked functions expressions
            - We've seen how using an immediately-invoked function expression creates a private scope that protects
            variables or methods from being accessed. IIFE's ultimately use the returned functions to access private
            data within the closure. This works out very well: while these returned functions are publicly-accessible,
            they still maintain privacy for the variables defined within them!
            - Another great opportunity to use an IFFE is when you want to execute some code without creating extra
            global variables. However, note that an IIFE is only intended to be invoked once, to create a unique
            execution context. If you have some code that is expected to be re-used (e.g., a function meant to be
            executed more than once in the application), declaring the function and then invoking it might be a better option.

C. classes and objects
    1. constructor functions
        - Previously, we have created objects using the object literal notation. Likewise, we can even write functions
        that return objects. There is yet another way for us to create objects, and it is the foundation of
        object-oriented JavaScript: the constructor function. We saw a bit of it back in Lesson 1 when invoking the
        Object() constructor function. Now, let's take a deeper dive into it!
        - To instantiate (i.e., create) a new object, we use the new operator to invoke the function:

        new SoftwareDeveloper();

        - The first thing to note above is the use of the new keyword. Second, note that the name of the constructor
        function, SoftwareDeveloper(), is written with the first letter capitalized to visually distinguish it from a
        regular function.
        - Keep in mind that even though the function's name starts with a capital, that doesn't automatically make this
        a constructor function (i.e., though developers name constructor functions in CamelCase by convention, it is not
        enforced by the language). What does make SoftwareDeveloper() a constructor function are:

            The use of the new operator to invoke the function
            How the function is coded internally (which we'll look at right now!)

        b. constructor functions: structure and syntax
            - This is what the internals of a constructor function looks like:

            function SoftwareDeveloper() {
              this.favoriteLanguage = 'JavaScript';
            }

            - First, rather than declaring local variables, constructor functions persist data with the this keyword.
            The above function will add a favoriteLanguage property to any object that it creates, and assigns it a
            default value of 'JavaScript'. Don't worry too much about this in a constructor function for now; just know
            that this refers to the new object that was created by using the new keyword in front of the constructor
            function. We'll go into more detail about this soon!
            - One last thing that might seem unusual is that this function doesn't seem to return anything! Constructor
            functions in JavaScript should not have an explicit return value (i.e., there should not be return statement).

        c. creating a new object
            -  As we've seen above, let's use the new operator to create a new object:

            let developer = new SoftwareDeveloper();

        d. creating multiple pbjects
            - Let's invoke the same SoftwareDeveloper() constructor two more times to instantiate two additional objects:
            engineer and programmer.

            let engineer = new SoftwareDeveloper();
            let programmer = new SoftwareDeveloper();
            console.log(engineer);
            // SoftwareDeveloper { favoriteLanguage: 'JavaScript' }
            console.log(programmer);
            // SoftwareDeveloper { favoriteLanguage: 'JavaScript' }

        e. constructor functions can have parameters
            - Just like regular functions, one benefit of using constructor functions is that they can also accept
            arguments. Let's update the constructor above to accept a single argument, and assign the name property to it:

            function SoftwareDeveloper(name) {
              this.favoriteLanguage = 'JavaScript';
              this.name = name;
            }

            - In the updated SoftwareDeveloper() function, whatever value is passed into the function will be the value
            of the object's name property. Let's check it out:

            let instructor = new SoftwareDeveloper('Andrew');
            console.log(instructor);
            // SoftwareDeveloper { favoriteLanguage: 'JavaScript', name: 'Andrew' }

            - Great! And as we've seen above, we can create different objects using the same constructor. Let's call the
            same constructor function but pass a different argument this time:

            let teacher = new SoftwareDeveloper('Richard');

            console.log(teacher);
            // SoftwareDeveloper { favoriteLanguage: 'JavaScript', name: 'Richard' }

        f. omitting the new operator
            - What's going on? Without using the new operator, no object was created. The function was invoked just like
            any other regular function. Since the function doesn't return anything (except undefined, which all functions
            return by default), the coder variable ended up being assigned to undefined.
            - One more thing to note: since this function was invoked as a regular function, the value of this is also
            drastically different. Don't worry too much about this for now; we'll take a deep dive into the this keyword
            in the very next section!
        g. seeing the object's constructor (instanceof)
            -  What if we want to see if an object was created with a constructor function in the first place? We can
            use the instanceof (which returns a boolean) to give us some insight.
            - instanceof and the prototype chain
                - In the above example, instanceof confirmed that a specific constructor function did in fact create a
                specific object. We know this because we directly instantiated the dev object after invoking the
                Developer() constructor function.
                - Many times, however, it's a bit more complex: the instanceof operator actually tests whether or not
                that constructor appears in the prototype chain of an object. This means that we can't always check
                exactly which constructor created that object, but it does give us insight as to what other properties
                and methods an object may have access to.
        h. summary
            - JavaScript's class system is built directly on using functions and objects. Calling (i.e., invoking) a
            constructor function with the new operator instantiates a new object. The same constructor function can be
            used to create different objects.
            - We've discussed functions, objects, and this throughout this course. As it turns out, all three are very
            much interconnected with one another! We'll examine their relationship in the next section as we take an
            in-depth look at the this keyword.
    2. the this keyword
        a. In the previous section, we saw this right inside a constructor function. Here's another example:

            function Cat(name) {
             this.name = name;
             this.sayName = function () {
               console.log(`Meow! My name is ${this.name}`);
             };
            }
            const bailey = new Cat('Bailey');

            - In the above Cat() constructor, the function that sayName references this.name. Back in Lesson 1, we saw this
            used in methods. But in Cat()'s case, what exactly does this refer to?

            - As it turns out, when invoking a constructor function with the new operator, this gets set to the
            newly-created object! Let's check out what the new bailey object looks like:

            {
              name: 'Bailey',
              sayName: function () {
                console.log(`Meow! My name is ${this.name}`);
              }
            }

            - In the snippet above, notice that this is outside a constructor function (i.e., in a method). As we saw in
            Lesson 1, when you say this in a method, what you're really saying is "this object" or "the object at hand."
            As a result, the sayName() method can use this to access the name property of that object! This makes the
            following method call possible:

            bailey.sayName();
            // 'Meow! My name is Bailey'

            - Note: For a refresher on how a method uses this to access an object on which it was called, feel free to
            review Invoking Object Methods in Lesson 1.

        b. when is this assigned?
            - A common misconception is that this refers to the object where it is defined. This is not the case!
            - The value of this is actually not assigned to anything until an object calls the method where this is used.
            In other words, the value assigned to this is based on the object that invokes the method where this is
            defined. Let's look at an example:

            const dog = {
              bark: function () {
                console.log('Woof!');
              },
              barkTwice: function () {
                this.bark();
                this.bark();
              }
            };
            dog.bark();
            // Woof!
            dog.barkTwice();
            // Woof!
            // Woof!

            - We know that when we call dog.bark(); (or dog.barkTwice();) a variable this gets set. Since this can
            access the object it was called on, barkTwice can use this to access the dog object, which contains the bark
            method.
            - But what if we just wrote bark(); instead of this.bark(); in barkTwice? The function would have first
            looked for a local variable named bark in the scope of barkTwice. If bark isn't found, it would have looked
            further up the scope chain.
        c. what does this get set to?
            - At this point, we've seen this in many different contexts, such as within a method, or referenced by a
            constructor function. Let's now organize our thoughts and bring it all together!
            - There are four ways to call functions, and each way sets this differently.
            - First, calling a constructor function with the new keyword sets this to a newly-created object. Recall
            that creating an instance of Cat earlier had set this to the new bailey object.
            - On the other hand, calling a function that belongs to an object (i.e., a method) sets this to the object
            itself. Recall that earlier, the dog object's barkTwice() method was able to access properties of dog itself.

            function funFunction() {
              return this;
            }
            funFunction();
            // (returns the global object, `window`)

            - The fourth way to call functions allows us to set this ourselves! Don't worry about this approach for now;
            we'll take a deep dive in the very next section.

    3. setting our own this with call() apply() and bind()
        a.  Each method can be directly invoked onto a function itself (after all, JavaScript functions are first-class
        functions and can have properties and methods). As a result, the receiving function will be invoked with a
        specified this value, as well as any arguments passed in.
        b. call()
            - call() is a method directly invoked onto a function. We first pass into it a single value to set as the
            value of this; then we pass in any of the receiving function's arguments one-by-one, separated by commas.
            - Consider the following function, multiply(), which simply returns the product of its two arguments:

            function multiply(n1, n2) {
              return n1 * n2;
            }

            - Let's invoke it in the console:

            multiply(3, 4);
            // 12

            multiply.call(window, 3, 4);
            // 12

            - After writing that part, it's time to pass in the arguments! For the first argument of the call() method,
            we pass in the value to be set as this, which is window. We then finish up by passing in the multiply()
            function's arguments individually, separated by commas.
            - Once multiply.call(window, 3, 4); executes, the function will be invoked with the given value of this, and
            the result that we see is 12. Outside of strict mode, both ways of invoking multiply() above are equivalent.
            - Along with invoking regular functions, how do we go upon invoking functions attached to objects
            (i.e., methods)? This is where the power of call() really shines. Using call() to invoke a method allows us
            to "borrow" a method from one object -- then use it for another object! Check out the following object,
            mockingbird:

            const mockingbird = {
              title: 'To Kill a Mockingbird',
              describe: function () {
                console.log(`${this.title} is a classic novel`);
              }
            };

            - We can have mockingbird invoke its own describe() method:

            mockingbird.describe();
            // 'To Kill a Mockingbird is a classic novel'

            - Using call(), however, the following pride object can utilize mockingbird's describe() method:

            const pride = {
              title: 'Pride and Prejudice'
            };
            mockingbird.describe.call(pride);
            // 'Pride and Prejudice is a classic novel'

            - First, the call() method is invoked onto mockingbird.describe (which points to a function). Then, the
            value of this is passed into the call() method: pride.
            - Since mockingbird's describe() method references this.title, we need to access the title property of the
            object that this refers to. But since we've set our own value of this, the value of this.title will be
            accessed from the pride object! As a result, mockingbird.describe.call(pride); is executed, and we see
            'Pride and Prejudice is a classic novel' in the console.
            - call() is very effective if you're looking to invoke a function in the scope of the first argument passed
            into it. Likewise, we can leverage the apply() method to do the same, albeit with differences in how
            arguments are passed into it. Let's take a closer look!
        c. apply()
            - Just like call(), the apply() method is called on a function to not only invoke that function, but also to
            associate with it a specific value of this. However, rather than passing arguments one-by-one, separated by
            commas -- apply() takes the function's arguments in an array. Recall the multiply() function from earlier:

            function multiply(n1, n2) {
              return n1 * n2;
            }

            - We used call() and passed in arguments individually:

            multiply.call(window, 3, 4);
            // 12

            - Using apply(), however, we collect all of the multiply() function's arguments in an array! Then, we pass
            that entire array into apply():

            multiply.apply(window, [3, 4]);
            // 12

            mockingbird.describe.apply(pride);
            // 'Pride and Prejudice is a classic novel'

            - Note that the first argument passed into both call() and apply() is the same: pride. Since the describe()
            method doesn't take any arguments, the only difference between mockingbird.describe.call(pride); and
            mockingbird.describe.apply(pride); is just the method! Both approaches produce the same result.
        d. Choosing One Method Over the Other
            - Both call() and apply() invoke a function in the scope of the first argument passed in them (i.e., the
            object to be the value of this). So when would you choose call() over apply(), or vice versa?
            - call() may be limited if you don't know ahead of time the number of arguments that the function needs. In
            this case, apply() would be a better option, since it simply takes an array of arguments, then unpacks them
            to pass along to the function. Keep in mind that the unpacking comes at a minor performance cost, but it
            shouldn't be much of an issue.
        e. Saving this with an Anonymous Closure
            - Recall that simply invoking a normal function will set the value of this to the global object (i.e., window). This is an issue, because we want this to be the dog object!
            - So how can we make sure that this is preserved?
            - One way to resolve this issue is to use an anonymous closure to close over the dog object:

            invokeTwice(function () {
              dog.growOneYear();
            });
            dog.age;
            // 7
        f. Saving this with bind()
            - Similar to call() and apply(), the bind() method allows us to directly define a value for this. bind() is
            a method that is also called _on_ a function, but unlike call() or apply(), which both invoke the function
            right away -- bind() returns a new function that, when called, has this set to the value we give it.
            - summary
                  JavaScript provides three methods that allow us to set the value of this for a given function:

                  call() invokes the function and has arguments passed in individually, separated by commas.
                  apply() is similar to call(); it invokes the function just the same, but arguments are passed in as an array.
                  bind() returns a new function with this bound to a specific object, allowing us to call it as a regular function.
                  For further research, we recommend checking out Kyle Simpson's You Don't Know JS series on this, linked below.

                  At this point, you've seen how functions, objects, and the this keyword are all very much interconnected.
                  You've also seen how just about everything in JavaScript is an object!

                  Did you know that you can even base objects on other objects? This is the main idea behind prototypal
                  inheritance, and by implementing it, objects can take on properties of other objects. We'll cover all this
                  and more, coming up next!
    4. Prototypal Inheritance
        a. adding methods to the protoype
            - Recall that objects contain data (i.e., properties), as well as the means to manipulate that data (i.e.,
            methods). Earlier in this Lesson, we simply added methods directly into the constructor function itself:

            function Cat(name) {
             this.lives = 9;
             this.name = name;

             this.sayName = function () {
               console.log(`Meow! My name is ${this.name}`);
             };
            }

            - This way, a sayName method gets added to all Cat objects by saving a function to the sayName attribute of
            newly-created Cat objects.
            - This works just fine, but what if we want to instantiate more and more Cat objects with this constructor?
            You'll create a new function every single time for that Cat object's sayName! What's more: if you ever want
            to make changes to the method, you'll have to update all objects individually. In this situation, it makes
            sense to have all objects created by the same Cat constructor function just share a single sayName method.
            - To save memory and keep things DRY, we can add methods to the constructor function's prototype property.
            The prototype is just an object, and all objects created by a constructor function keep a reference to the
            prototype. Those objects can even use the prototype's properties as their own!
            - Recall that each function has a prototype property, which is really just an object. When this function is
            invoked as a constructor using the new operator, it creates and returns a new object. This object is
            secretly linked to its constructor's prototype, and this secret link allows the object to access the
            prototype's properties and methods as if it were its own!
            - Since we know that the prototype property just points to a regular object, that object itself also has a
            secret link to its prototype. And that prototype object also has reference to its own prototype -- and so
            on. This is how the prototype chain is formed.
        b. finding properties and methods on the prototype chain
            - Whether you're accessing a property (e.g., bailey.lives;) or invoking a method (e.g., bailey.meow();), the
            JavaScript interpreter looks for them along the prototype chain in a very particular order:
                - First, the JavaScript engine will look at the object's own properties. This means that any properties and
                methods defined directly in the object itself will take precedence over any properties and methods
                elsewhere if their names are the same (similar to variable shadowing in the scope chain).
                - If it doesn't find the property in question, it will then search the object's constructor's prototype
                for a match.
                - If the property doesn't exist in the prototype, the JavaScript engine will continue looking up the chain.
                - At the very end of the chain is the Object() object, or the top-level parent. If the property still
                cannot be found, the property is undefined.
        c.  Replacing the prototype Object
            - What happens if you completely replace a function's prototype object? How does this affect objects created
            by that function? Let's look at a simple Hamster constructor function and instantiate a few objects:

            function Hamster() {
              this.hasFur = true;
            }
            let waffle = new Hamster();
            let pancake = new Hamster();

            Hamster.prototype.eat = function () {
              console.log('Chomp chomp chomp!');
            };
            waffle.eat();
            // 'Chomp chomp chomp!'
            pancake.eat();
            // 'Chomp chomp chomp!'

            Hamster.prototype = {
              isHungry: false,
              color: 'brown'
            };

            - The previous objects don't have access to the updated prototype's properties; they just retain their
            secret link to the old prototype:

            console.log(waffle.color);
            // undefined
            waffle.eat();
            // 'Chomp chomp chomp!'
            console.log(pancake.isHungry);
            // undefined

            - As it turns out, any new Hamster objects created moving forward will use the updated prototype:
            const muffin = new Hamster();

            muffin.eat();
            // TypeError: muffin.eat is not a function
            console.log(muffin.isHungry);
            // false
            console.log(muffin.color);
            // 'brown'

        d. checking an objects properties
            - hasOwnProperty()
                - hasOwnProperty() allows you to find the origin of a particular property. Upon passing in a string of
                the property name you're looking for, the method will return a boolean indicating whether or not the
                property belongs to the object itself (i.e., that property was not inherited). Consider the Phone
                constructor with a single property defined directly in the function, and another property on its
                prototype object:

                function Phone() {
                  this.operatingSystem = 'Android';
                }
                Phone.prototype.screenSize = 6;

                const myPhone = new Phone();
                const own = myPhone.hasOwnProperty('operatingSystem');
                console.log(own);
                // true

                const inherited = myPhone.hasOwnProperty('screenSize');
                console.log(inherited);
                // false

            - isPrototypeOf()
                - Objects also have access to the isPrototypeOf() method, which checks whether or not an object exists
                in another object's prototype chain. Using this method, you can confirm if a particular object serves
                as the prototype of another object. Check out the following rodent object:

                const rodent = {
                  favoriteFood: 'cheese',
                  hasTail: true
                };

                function Mouse() {
                  this.favoriteFood = 'cheese';
                }
                Mouse.prototype = rodent;

                const ralph = new Mouse();
                const result = rodent.isPrototypeOf(ralph);
                console.log(result);
                // true

            - Object.getPrototypeOf()
                - isPrototypeOf() works well, but keep in mind that in order to use it, you must have that prototype
                object at hand in the first place! What if you're not sure what a certain object's prototype is?
                Object.getPrototypeOf() can help with just that!
                - Using the previous example, let's store the return value of Object.getPrototypeOf() in a variable,
                myPrototype, then check what it is:

                const myPrototype = Object.getPrototypeOf(ralph);
                console.log(myPrototype);
                // { favoriteFood: 'cheese', hasTail: true }

                - Great! The prototype of ralph has the same properties as the result because they are the same object.
                Object.getPrototypeOf() is great for retrieving the prototype of a given object.

        e. the constructor property
            - Each time an object is created, a special property is assigned to it under the hood: constructor.
            Accessing an object's constructor property returns a reference to the constructor function that created that
            object in the first place! Here's a simple Longboard constructor function. We'll also go ahead and make a
            new object, then save it to a board variable:

            function Longboard() {
              this.material = 'bamboo';
            }
            const board = new Longboard();

            If we access board's constructor property, we should see the original constructor function itself:

            console.log(board.constructor);
            // function Longboard() {
            //   this.material = 'bamboo';
            // }

            Excellent! Keep in mind that if an object was created using literal notation, its constructor is the built-in
            Object() constructor function!

            const rodent = {
              favoriteFood: 'cheese',
              hasTail: true
            };
            console.log(rodent.constructor);
            // function Object() { [native code] }
        f. summary
            - Inheritance in JavaScript is when an object is based on another object. Inheritance allows us to reuse
            existing code, having objects take on properties of other objects.
            - When a function is called as a constructor using the new operator, the function creates and returns a new
            object. This object is secretly linked to its constructor's prototype, which is just another object. Using
            this secret link allows an object to access the prototype's properties and methods as if it were its own.
            If JavaScript does not find a particular property within an object, it will keep looking up the prototype
            chain, eventually reaching Object() (top-level parent) if necessary.
            - We also looked at a few methods and properties that allow use to check the origins and references of
            objects and their prototypes, namely:

              hasOwnProperty()
              isPrototypeOf()
              Object.getPrototypeOf()
              .constructor

            - In the next section, we'll check out another part of prototypal inheritance in the form of subclassing.
            What if you want to inherit just a few properties from an object -- but want an object to also have other,
            specialized properties of their own? We'll take an even deeper dive into prototypal inheritance in the next
            section!

    5. prototypal inheritance, subclasses
        a. subclasses
            - One of the benefits of implementing inheritance is that it allows you to reuse existing code. By
            establishing inheritance, we can subclass, that is, have a "child" object take on most or all of a "parent"
            object's properties while retaining unique properties of its own.
            - Let's say we have a parent Animal object, which contains properties like age and weight. That same Animal
            object can also access methods like eat and sleep.
            - Now, let's also say that we want to create a Cat child object. Just like you can with other animals, you
            can also describe a cat by its age or weight, and you can also be certain that the cat eats and sleeps as
            well. When creating that Cat object, then, we can simply re-write and re-implement all those methods and
            properties from Animal -- or, we can save some time and prevent repeated code by having Cat inherit those
            existing properties and methods from Animal!
            - Not only can Cat take on properties and methods of Animal, we can also give Cat its own unique properties
            and methods as well! Perhaps a Cat has a unique lives property of 9, or it has a specialized meow() method
            that no Animal has.
        b. the secret link
            - As you know, an object's constructor function's prototype is first place searched when the JavaScript
            engine tries to access a property that doesn't exist in the object itself. Consider the following bear
            object with two properties, claws and diet:

            const bear = {
              claws: true,
              diet: 'carnivore'
            };

            function PolarBear() {
              // ...
            }
            PolarBear.prototype = bear;

            const snowball = new PolarBear();
            snowball.color = 'white';
            snowball.favoriteDrink = 'cola';

            {
              color: 'white',
              favoriteDrink: 'cola'
            }

            console.log(snowball.claws);
            // true
            console.log(snowball.diet);
            // 'carnivore'

            - Since claws and diet both exist as properties in the prototype object, they are looked up because objects
            are secretly linked to their constructor's prototype property.
            - Great! But you may be wondering: just what is this secret link that leads to the prototype object? Right
            after objects are made from the PolarBear() constructor (such as snowball), they have immediate access to
            properties in PolarBear()'s prototype. How exactly is this possible?
            - As it turns out, the secret link is snowball's __proto__ property (note the two underscores on each end).
            __proto__ is a property of all objects (i.e., instances) made by a constructor function, and points directly
            to that constructor's prototype object. Let's check out what it looks like!

            console.log(snowball.__proto__);
            // { claws: true, diet: 'carnivore' }

            console.log(snowball.__proto__ === bear);
            // true

            - It is highly discouraged to reassign the __proto__ property, or even use it in any code you write. First,
            there are compatibility issues across browsers. What's more: since the JavaScript engine searches and
            accesses properties along the prototype chain, mutating an object's prototype can lead to performance issues.
            The MDN article for proto even warns against using this property in red text at the very top of the page!
            - It's great to know the secret link for learning how functions and objects are interconnected, but you
            should not use __proto__ to manage inheritance. If you ever just need to review an object's prototype, you
            can still use Object.getPrototypeOf().
        c.  What About Just Inheriting the Prototype?
            -  Let's say we want a Child object to inherit from a Parent object. Why shouldn't we just set
            Child.prototype = Parent.prototype?
            - First, recall that objects are passed by reference. This means that since the Child.prototype object and
            the Parent.prototype object refer to the same object -- any changes you make to Child's prototype will also
            be made to Parent's prototype! We don't want children being able to modify properties of their parents!
            - On top of all this, no prototype chain will be set up. What if we want an object to inherit from any object
            we want, not just its prototype?
            - We still need a way to efficiently manage inheritance without mutating the prototype at all.
        d. Object.create()
            - At this point, we've reached a few roadblocks when it comes to inheritance. First, even though __proto__
            can access the prototype of the object it is called on, using it in any code you write is not good practice.
            - What's more: we also shouldn't inherit only the prototype; this doesn't set up the prototype chain, and
            any changes that we made to a child object will also be reflected in a parent object.
            - There's actually a way for us to set up the prototype of an object ourselves: using Object.create().
            And best of all, this approach lets us manage inheritance without altering the prototype!
            - Object.create() takes in a single object as an argument, and returns a new object with its __proto__
            property set to what argument is passed into it. From that point, you simply set the returned object to be
            the prototype of the child object's constructor function. Let's check out an example!
            - First, let's say we have a mammal object with two properties: vertebrate and earBones:

            const mammal = {
              vertebrate: true,
              earBones: 3
            };

            - Recall that Object.create() takes in a single object as an argument, and returns a new object. That new
            object's __proto__ property is set to whatever was originally passed into Object.create(). Let's save that
            returned value to a variable, rabbit:

            const rabbit = Object.create(mammal);

            console.log(rabbit);
            // {}

            - However, rabbit should now be secretly linked to mammal. That is, its __proto__ property should point to
            mammal:

            console.log(rabbit.__proto__ === mammal);
            // true

            console.log(rabbit.vertebrate);
            // true
            console.log(rabbit.earBones);
            // 3

D. Design patterns
    1. mixins / extending object functionality with mixins
        a. An Object is Prototype-linked to a Single Object
            - Recall that an object's .prototype property points to just one object. This is because JavaScript only
            supports single inheritance. If there is an object A and an object B, object C can only be prototype-linked
            to either A _or_ B.
        b. mixins
            - If a JavaScript object can only be prototype-linked to a single object, how can we go about extending
            properties and methods from multiple different sources? A mixin allows us to just that!
            - A mixin is a technique that takes the properties and methods from one object and copies them over to
            another object. In other words: a mixin is an technique that provides some useful functionality, but is not
            meant to be added to the prototype chain.
            - Did you know that the term mixin is actually inspired by ice cream? The concept of a basic flavor being
            mixed in with several different extra items (e.g. nuts, fudge, cookies, sprinkles, etc.) was later adopted
            by computer scientists in object-oriented programming. What a tasty revelation!
        c.  Object.assign()
            - The simplest way to implement the mixin pattern is to use Object.assign(). Object.assign() is a method
            that copies an object's own (non-inherited) properties from one or more source objects into a target object,
            then returns the updated target object. In other words, Object.assign() adds to the target object by merging
            in the source object(s). Consider the following:

            let target = {};
            let source = { number: 7 };
            Object.assign(target, source);
            console.log(target);
            // { number: 7 }

            - The first argument passed in, target, is the destination that receives the properties copied from the
            source object, source. Note that Object.assign() does not create and return a new object; it directly
            modifies then returns the same target object that was passed in! As such, values of existing properties will
            be overwritten, while properties that don't exist in the source object will remain intact:

            let target = { letter: 'a', number: 11 };
            let source = { number: 7 };
            Object.assign(target, source);
            console.log(target);
            // { letter: 'a', number: 7 }

            - In the above example, the value of target's number property was overwritten, while its letter property was
            ignored.

        d. multiple source objects
            - Object.assign() can even take in multiple different source objects. Let's create a platypus object by
            mixing in properties from other animals:

            const duck = {
              hasBill: true
            };
            const beaver = {
              hasTail: true
            };
            const otter = {
              hasFur: true,
              feet: 'webbed'
            };
            const platypus = Object.assign({}, duck, beaver, otter);
            console.log(platypus);
            // { hasBill: true, hasTail: true, hasFur: true, feet: 'webbed' }

            platypus.constructor;
            // Object()
            platypus.isPrototypeOf(duck);
            // false
            duck.isPrototypeOf(platypus);
            // false
            platypus.isPrototypeOf(beaver);
            // false
            beaver.isPrototypeOf(duck);
            // false
            platypus.isPrototypeOf(otter);
            // false
            otter.isPrototypeOf(platypus);
            // false

        e. Object.assign() Compatibility
            - Object.assign() is a great way to copy properties own properties into a given object. Keep in mind that
            since it was introduced to the official specification in ES2015 (ES6), you may need to review browser
            compatibility to make sure it'll work in your environment.
    2.
        a. remember constructor functions
              function City(name, population) {
                this.name = name;
                this.population = population;
                this.identify = function () {
                  console.log(`${this.name}'s population is ${this.population}.`);
                };
              }

              const sanFrancisco = new City('San Francisco', 870000);
              console.log(sanFrancisco);
              // {
              //   name: 'San Francisco',
              //   population: 870000,
              //   identify: function () {
              //     console.log(`${this.name}'s population is ${this.population}.`);
              //   };
              // }

              const mountainView = new City('Mountain View', 78000);

              console.log(mountainView);
              // {
              //   name: 'Mountain View',
              //   population: 78000,
              //   identify: function () {
              //     console.log(`${this.name}'s population is ${this.population}.`);
              //   };
              // }

        b. Factory functions
            - A factory function is a function that returns an object, but isn't itself a class or constructor. As such,
            we invoke a factory function as a normal function without using the new operator. Using a factory function,
            we can easily create object instances without the complexity of classes and constructors!

            function Basketball(color) {
              return {
                color: color,
                numDots: 35000
              };
            }

            - What's important to note here is that Basketball() returns an object directly. This is different from a
            constructor function which returns its object automatically.
            - Let's invoke Basketball() and check out its output:

            const orangeBasketball = Basketball('orange');
            console.log(orangeBasketball);
            // { color: 'orange', numDots: 35000 }

            - A factory function has its name because, just like a chair factory can produce chair after chair after
            chair, a factory function can be used over and over to create any number of objects:

                - const myBB = Basketball('blue and green');
                - const yourBB = Basketball('purple');
                - const bouncy = Basketball('neon pink');

        c. functional mixins
            - In the previous section, we used mixins to add features into a composite object. We also just leveraged
            factory functions to create objects without using the new operator or messing with prototypal inheritance.
            Let's combine what we've learned from mixins and factory functions and take things a step further with
            functional mixins!

            function CoffeeMaker(object) {
              let needsRefill = false;
              return Object.assign({}, object, {
                pourAll: function () {
                  needsRefill = true;
                },
                isEmpty: function () {
                  return needsRefill;
                }
              });
            }

            - Note that unlike a standard factory function, which takes in individual property values as arguments --
            the functional mixin actually takes in an object itself! Whichever object is passed in to the function, is
            merged with other objects passed into Object.assign().

            const mixedCoffeeMaker = CoffeeMaker({ style: 'percolator' });

            {
              style: 'percolator',
              pourAll: function () {
                needsRefill = true;
              },
              isEmpty: function () {
                return needsRefill;
              }
            }

            - A factory function creates objects. It is invoked as normal function, not with the new operator. Functional
            mixins take things a bit further by accepting a mixin as an argument, copies properties and methods from the
            mixin, and returns a new object.

        3. the module pattern
            a. Private Properties: Function
                - Since JavaScript has _no_ concept of private properties out-of-the-box, there is no special syntax or
                keyword we can use to protect certain properties from being accessed.
                - However, there is hope! Recall from earlier lessons that we can use scope and closures to create a
                private state. Let's look at a quick refresher:

                function myCounter() {
                  let count = 0;

                  return function () {
                    count += 1;
                    return count;
                  };
                }
                let counter = myCounter();

                counter();
                // 1
                counter();
                // 2

                counter.count;
                // undefined
                count;
                // undefined

        4. the revealing module pattern
            a. The Revealing Module Pattern
                - The underlying philosophy of the Revealing Module Pattern is that, while we still maintain
                encapsulation (as in the Module Pattern), we also reveal certain properties (and methods). The key
                ingredients to the Revealing Module Pattern are:
                    - An IIFE (wrapper)
                    - The module content (variables, methods, objects, etc.)
                    - A returned object literal

                let person = (function () {
                  let privateAge = 0;
                  let privateName = 'Andrew';
                  function privateAgeOneYear() {
                    privateAge += 1;
                    console.log(`One year has passed! Current age is ${privateAge}`);
                  }
                  function displayName() {
                    console.log(`Name: ${privateName}`);
                  }
                  function ageOneYear() {
                    privateAgeOneYear();
                  }
                  return {
                    name: displayName,
                    age: ageOneYear
                  };
                })();

                - In the above snippet, the IIFE has some private data: privateAge, privateName, and privateAgeOneYear().
                The returned object is stored in person and provides a public interface through which we can access this
                data!
                - Let's first check out what the returned person looks like:

                {
                    name: displayName,
                    age: ageOneYear
                };

                - Note that the name() method reveals the otherwise private displayName() function:

                console.log(person.name());
                // 'My name is Andrew'

                - However, what happens if we try to access and mutate privateName?

                person.privateName = 'Richard';
                console.log(person.name());
                // 'My name is Andrew'

                - person.name() still produces the string My name is Andrew! Why don't we see the string 'Richard' in
                the returned string?
                - Pay close attention to what the first line of code is actually doing: it simply adds a privateName
                property to the person object. It has no effect on the privateName variable that exists inside the IIFE
                itself! If we look at the person.name() function, it is using the privateName variable that exists
                inside the IIFE. So even if we add a person.privateName property, the person.name() method doesn't ever
                try to access it.
                - Note that accessing displayName() directly won't be effective, either! This should come as now
                surprise, since displayName() is just a function defined inside the IIFE (i.e., displayName() is not
                a property in the returned object).
            b. Benefits of the Revealing Module Pattern
                - When writing your modules, there are a few key advantages of using the Revealing Module Pattern. For
                one, there is clarity at the end of the module (i.e., the return statement) as to which variables or
                methods may be accessed publicly. Modules may grow large, and this eases readability for other
                developers who read your code.
                - Along with clear intent of public or private data, the Revealing Module Pattern lends itself to
                consistent syntax as well. In contrast, the normal Module Pattern may contain variables and functions
                spread throughout the entire function body.
                - While you can't go wrong with either approach to create private properties in your code, be sure to
                take the time and choose which makes the most sense for your project!


                https://github.com/sohamkamani/javascript-design-patterns-for-humans
                https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e
